# Metaprogramming



---

**Resources:**

[元编程 · the missing semester of your cs education](https://missing-semester-cn.github.io/2020/metaprogramming/)

[概述 — 跟我一起写Makefile 1.0 文档](https://seisman.github.io/how-to-write-makefile/overview.html)





---



## 构建系统

对于大多数系统来说，不论其是否包含代码，都会包含一个 “构建过程”。有时，您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。例如如果我们的项目由成百上千个 C 源文件组成，并且星罗棋布在各个子目录下，该如何将它们编译链接到一起呢？假如项目编译一次需要半个小时（大型项目相当常见），而我们在某次只修改了一个分号，再次编译是不是还需要再等半个小时呢？幸运的是，有很多工具可以帮助我们完成这些操作并避免以上问题。

这些工具通常被称为 “构建系统”，而且这些工具还不少。如何选择工具完全取决于当前手头上要完成的任务以及项目的规模。从本质上讲，这些工具都是非常类似的，我们需要定义 **依赖**、**目标** 和 **规则**，即必须告诉构建系统您具体的构建**目标**，系统的任务则是找到构建这些目标所需要的**依赖**，并根据**规则**构建所需的中间产物，直到最终**目标**被构建出来。理想的情况下，如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行。

`make` 是最常用的构建系统之一，它通常被安装到了几乎所有基于 UNIX 的系统中。`make` 并不完美，但是对于中小型项目来说，它已经足够好了。当执行 `make` 时，它会去参考当前目录下名为 `Makefile` 的文件。所有构建目标、相关依赖和规则都需要在该文件中定义。

更详细的`Makefile`书写与`make`的使用见[Makefile](Makefile.md)。



## 依赖管理

就一个项目来说，它的依赖可能本身也是其他的项目，它也许会依赖某些程序（例如 `python`）、系统包（例如 `openssl`）或相关编程语言的编程库（例如 `matplotlib`）。 现在，大多数的依赖可以通过某些 **软件仓库** 来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。例如 Ubuntu 系统下面有 Ubuntu 软件包仓库，可以通过 `apt` 这个工具来访问；RubyGems 则包含了 Ruby 的相关库；PyPi 包含了 Python 库； Arch Linux 用户贡献的库则可以在 Arch User Repository 中找到；而绝大多数开源库都可以在Github上找到。

大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个 **版本号**。通常看上去像 8.1.3 或 64.1.20192004。版本号一般是数字构成的，但也并不绝对。版本号有很多用途，其中最重要的作用是保证软件能够运行。试想一下，假如我的库要发布一个新版本，在这个版本里面我重命名了某个函数。如果有人在我的库升级版本后，仍希望基于它构建新的软件，那么很可能构建会失败，因为它希望调用的函数已经不复存在了。有了版本控制就可以很好的解决这个问题，我们可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。

这样还并不理想！如果我们发布了一项和安全相关的升级，它并没有影响到任何公开接口（API），但是处于安全的考虑，依赖它的项目都应该立即升级，那应该怎么做呢？这也是版本号包含多个部分的原因。不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是 [语义版本号](https://semver.org/)，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有：

- 如果新的版本没有改变 API，请将补丁号递增；
- 如果您添加了 API 并且该改动是向后兼容的，请将次版本号递增；
- 如果您修改了 API 但是它并不向后兼容，请将主版本号递增。

这么做有很多好处。现在如果我们的项目是基于某个特定项目构建的，那么只要该项目最新版本的主版本号没变就是安全的 ，次版本号不低于之前我们使用的版本即可。换句话说，如果我依赖的版本是 `1.3.7`，那么使用 `1.3.8`、`1.6.1`，甚至是 `1.3.0` 都是可以的。如果版本号是 `2.2.4` 就不一定能用了，因为它的主版本号增加了。我们可以将 Python 的版本号作为语义版本号的一个实例，Python 2 和 Python 3 的代码就是不兼容的，这也是为什么 Python 的主版本号改变的原因。类似的，使用 Python 3.5 编写的代码在 3.7 上可以运行，但是在 3.4 上可能会不行。



## 持续集成系统

随着接触到的项目规模越来越大，我们会发现修改代码之后还有很多额外的工作要做，可能需要上传一份新版本的文档、上传编译后的文件到某处、发布代码到 pypi，执行测试套件等等。或许希望每次有人提交代码到 GitHub 的时候，他们的代码风格被检查过并执行过某些基准测试？如果您这方面的需求，那么持续集成会帮助我们实现。

持续集成（Continuous integration），或者叫做 CI 是一种雨伞术语（umbrella term，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西”，市场上有很多提供各式各样 CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis CI、Azure Pipelines 和 GitHub Actions。它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。
